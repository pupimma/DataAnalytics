import streamlit as st
import pandas as pd
import joblib
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# Configura√ß√£o da P√°gina
st.set_page_config(
    page_title="Predi√ß√£o de Obesidade",
    page_icon="üè•",
    layout="wide"
)

# --- CARREGAMENTO DO MODELO ---
@st.cache_resource
def load_model():
    try:
        # Tenta carregar o modelo. Se n√£o achar, retorna None
        return joblib.load('modelo_obesidade.pkl')
    except FileNotFoundError:
        return None
    except Exception as e:
        st.error(f"Erro ao carregar o modelo: {e}")
        return None

artifacts = load_model()

# --- VERIFICA√á√ÉO DE SEGURAN√áA ---
if artifacts is None:
    st.error("‚ùå ERRO CR√çTICO: O arquivo 'modelo_obesidade.pkl' n√£o foi encontrado.")
    st.warning("Certifique-se de que o arquivo .pkl est√° na mesma pasta que este script.")
    st.stop()

# Recupera os artefatos do modelo
model = artifacts["model"]
le = artifacts["label_encoder"]
feature_columns = artifacts["features"]

# --- T√çTULO E INTRODU√á√ÉO ---
st.title("üè• Sistema de Triagem de Obesidade")
st.markdown("""
Este sistema utiliza Intelig√™ncia Artificial para analisar fatores de risco e prever o diagn√≥stico 
de obesidade. Preencha os dados do paciente na barra lateral para obter o resultado.
""")

# --- BARRA LATERAL (Entrada em PORTUGU√äS -> Convers√£o para INGL√äS) ---
st.sidebar.header("üìã Dados do Paciente")

def user_input_features():
    # --- DADOS FISIOL√ìGICOS ---
    # O usu√°rio v√™ "Masculino", mas o sistema grava 1 (Male) ou 0 (Female) conforme seu treino original
    genero_label = st.sidebar.selectbox("G√™nero", ["Masculino", "Feminino"])
    gender = 1 if genero_label == "Masculino" else 0
    
    age = st.sidebar.number_input("Idade", 14, 100, 25)
    height = st.sidebar.number_input("Altura (m)", 1.00, 2.50, 1.70)
    weight = st.sidebar.number_input("Peso (kg)", 30.0, 200.0, 70.0)

    st.sidebar.markdown("---")
    
    # --- HIST√ìRICO E H√ÅBITOS (Tradu√ß√£o Visual) ---
    
    # Hist√≥rico Familiar (yes/no -> 1/0)
    hist_input = st.sidebar.selectbox("Hist√≥rico Familiar de Obesidade?", ["Sim", "N√£o"])
    family_history = 1 if hist_input == "Sim" else 0

    # Consumo Cal√≥rico (FAVC) (yes/no -> 1/0)
    favc_input = st.sidebar.selectbox("Consome alimentos cal√≥ricos com frequ√™ncia?", ["Sim", "N√£o"])
    favc = 1 if favc_input == "Sim" else 0

    # Vegetais (FCVC) (1 a 3)
    fcvc = st.sidebar.slider("Frequ√™ncia de consumo de vegetais (1=Nunca, 3=Sempre)", 1, 3, 2)

    # Refei√ß√µes (NCP) (1 a 4)
    ncp = st.sidebar.slider("N√∫mero de refei√ß√µes principais por dia", 1, 4, 3)

    # Beliscar (CAEC) (Scale -> 0,1,2,3)
    caec_map = {"N√£o": 0, "√Äs vezes": 1, "Frequentemente": 2, "Sempre": 3}
    caec_input = st.sidebar.selectbox("Come entre as refei√ß√µes?", list(caec_map.keys()))
    caec = caec_map[caec_input]

    # Fumante (SMOKE) (yes/no -> 1/0)
    smoke_input = st.sidebar.selectbox("Fumante?", ["Sim", "N√£o"])
    smoke = 1 if smoke_input == "Sim" else 0

    # √Ågua (CH2O) (1 a 3)
    ch2o = st.sidebar.slider("Consumo di√°rio de √°gua (1=Pouco, 3=Muito)", 1, 3, 2)

    # Monitora Calorias (SCC) (yes/no -> 1/0)
    scc_input = st.sidebar.selectbox("Monitora calorias ingeridas?", ["Sim", "N√£o"])
    scc = 1 if scc_input == "Sim" else 0

    # Atividade F√≠sica (FAF) (0 a 3)
    faf = st.sidebar.slider("Frequ√™ncia de atividade f√≠sica semanal (0=Nenhuma, 3=Muita)", 0, 3, 1)

    # Eletr√¥nicos (TUE) (0 a 2)
    tue = st.sidebar.slider("Tempo usando dispositivos eletr√¥nicos (0=Pouco, 2=Muito)", 0, 2, 1)

    # √Ålcool (CALC) (Scale -> 0,1,2,3)
    calc_map = {"N√£o": 0, "√Äs vezes": 1, "Frequentemente": 2, "Sempre": 3}
    calc_input = st.sidebar.selectbox("Consumo de √°lcool", list(calc_map.keys()))
    calc = calc_map[calc_input]

    # Transporte (MTRANS) - Precisa manter os nomes em INGL√äS para o OneHotEncoding funcionar depois
    transporte_map = {
        "Transporte P√∫blico": "Public_Transportation",
        "Caminhada": "Walking",
        "Autom√≥vel": "Automobile",
        "Motocicleta": "Motorbike",
        "Bicicleta": "Bike"
    }
    transporte_label = st.sidebar.selectbox("Meio de transporte principal", list(transporte_map.keys()))
    mtrans = transporte_map[transporte_label]

    # --- MONTAGEM DO DATAFRAME (COM NOMES ORIGINAIS EM INGL√äS) ---
    # Isso garante que o modelo antigo entenda os dados
    data = {
        'Gender': gender, 'Age': age, 'Height': height, 'Weight': weight,
        'family_history': family_history, 'FAVC': favc, 'FCVC': fcvc,
        'NCP': ncp, 'CAEC': caec, 'SMOKE': smoke, 'CH2O': ch2o,
        'SCC': scc, 'FAF': faf, 'TUE': tue, 'CALC': calc, 'MTRANS': mtrans
    }
    return pd.DataFrame(data, index=[0])

input_df = user_input_features()

# --- PR√â-PROCESSAMENTO FINAL ---
# Como j√° convertemos para n√∫meros manualmente acima, s√≥ falta o OneHot do Transporte
df_processed = pd.get_dummies(input_df, columns=['MTRANS'])

# Reindexar para garantir que todas as colunas que o modelo espera existam
# (Ex: Se escolheu "Carro", cria as colunas "Moto", "Bike" com valor 0)
df_processed = df_processed.reindex(columns=feature_columns, fill_value=0)

# --- PREDI√á√ÉO E RESULTADOS ---
if st.button("üîç Realizar Diagn√≥stico"):
    
    try:
        # Predi√ß√£o da Classe
        prediction = model.predict(df_processed)
        # Predi√ß√£o das Probabilidades
        prediction_proba = model.predict_proba(df_processed)
        
        # Recuperando o nome da classe
        resultado_texto_original = le.inverse_transform(prediction)[0]
        
        # TRADU√á√ÉO DO RESULTADO FINAL PARA O USU√ÅRIO
        traducao_resultado = {
            'Insufficient_Weight': 'Abaixo do Peso',
            'Normal_Weight': 'Peso Normal',
            'Overweight_Level_I': 'Sobrepeso N√≠vel I',
            'Overweight_Level_II': 'Sobrepeso N√≠vel II',
            'Obesity_Type_I': 'Obesidade Tipo I',
            'Obesity_Type_II': 'Obesidade Tipo II',
            'Obesity_Type_III': 'Obesidade Tipo III'
        }
        
        resultado_pt = traducao_resultado.get(resultado_texto_original, resultado_texto_original)
        
        # Calculando a confian√ßa
        confianca = np.max(prediction_proba) * 100

        # Exibi√ß√£o do Texto
        st.subheader("Resultado da An√°lise:")
        
        if "Obesity" in resultado_texto_original:
            st.error(f"‚ö†Ô∏è Diagn√≥stico: **{resultado_pt}**")
        elif "Overweight" in resultado_texto_original:
            st.warning(f"‚ö†Ô∏è Diagn√≥stico: **{resultado_pt}**")
        else:
            st.success(f"‚úÖ Diagn√≥stico: **{resultado_pt}**")
            
        st.info(f"üéØ N√≠vel de Confian√ßa do Modelo: **{confianca:.2f}%**")

        # --- GR√ÅFICO DE PROBABILIDADES ---
        st.markdown("---")
        st.subheader("üìä Probabilidades Detalhadas")
        
        # Cria dataframe para o gr√°fico, traduzindo as colunas
        proba_df = pd.DataFrame(prediction_proba, columns=[traducao_resultado.get(c, c) for c in le.classes_])
        
        fig, ax = plt.subplots(figsize=(10, 5))
        sns.barplot(x=proba_df.columns, y=proba_df.iloc[0].values, palette="viridis", ax=ax)
        plt.xticks(rotation=45, ha='right')
        plt.ylabel("Probabilidade (0-1)")
        plt.title("An√°lise de Risco por Categoria")
        st.pyplot(fig)

    except Exception as e:
        st.error(f"Erro ao realizar a predi√ß√£o: {e}")
        st.write("Verifique se as colunas enviadas correspondem √†s colunas treinadas.")
        st.write(f"Colunas esperadas: {feature_columns}")
        st.write(f"Colunas enviadas: {df_processed.columns.tolist()}")

# --- RODAP√â ---
st.markdown("---")
st.markdown("**Tech Challenge Fase 4** | Sistema de Apoio √† Decis√£o M√©dica")
